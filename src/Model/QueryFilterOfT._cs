using System;
using System.Collections.Generic;
using System.Linq;

namespace Tlabs.Data.Model {


  ///<summary>Generic filter paramters for a data queries on <typeparamref name="TEntity"/>.</summary>
  public class QueryFilter<TEntity> where TEntity : Tlabs.Data.Entity.Intern.BaseEntity {
    QueryFilter qfilter;

    ///<summary>Default ctor.</summary>
    public QueryFilter() {
      this.PrecursorPredicate= (q, pre) => q.Where(e => e.Id > pre.Id);
      this.PrecursorOrder= (q) => q.OrderBy(e => e.Id);
    }

    ///<summary>Copy ctor from <paramref name="qfilter"/></summary>
    public QueryFilter(QueryFilter qfilter) {
      this.Start= qfilter.Start;
      this.Limit= qfilter.Limit;
      if (null != (this.Properties= qfilter.Properties)) this.Properties= new Dictionary<string, IConvertible>(qfilter.Properties);
      if (null != (this.SortAscBy= qfilter.SortAscBy)) this.SortAscBy= new Dictionary<string, bool>(qfilter.SortAscBy);
      this.PrecursorPredicate= null;
      this.PrecursorOrder= null;
    }

    ///<summary>Copy ctor from <paramref name="other"/></summary>
    public QueryFilter(QueryFilter<TEntity> other) {
      this.Start= other.Start;
      this.Limit= other.Limit;
      if (null != (this.Properties= other.Properties)) this.Properties= new Dictionary<string, IConvertible>(other.Properties);
      if (null != (this.SortAscBy= other.SortAscBy)) this.SortAscBy= new Dictionary<string, bool>(other.SortAscBy);
      this.PrecursorPredicate= other.PrecursorPredicate;
      this.PrecursorOrder= other.PrecursorOrder;
    }

    ///<summary>Convertion from <see cref="QueryFilter"/>></summary>
    public static implicit operator QueryFilter<TEntity>(QueryFilter qfilter) => new QueryFilter<TEntity>(qfilter);

    ///<summary>Limit result to start at position (used with result paging).</summary>
    public virtual int? Start {
        get => qfilter.Start;
        set {
          if (value.HasValue) {
            PrecursorPredicate= null;
            PrecursorOrder= null;
          }
          qfilter.Start= value;
        }
      }

      ///<summary>Limit result to max. entries (used with result paging).</summary>
      public virtual int? Limit {
        get => qfilter.Limit;
        set => qfilter.Limit= value;
      }

      ///<summary>Limit result to to match these properties.</summary>
      public virtual IDictionary<string, IConvertible> Properties {
        get => qfilter.Properties;
        set => qfilter.Properties= value;
      }

      ///<summary>Sort result by these properties.</summary>
      ///<remarks>true: asc, false desc.</remarks>
      public virtual IDictionary<string, bool> SortAscBy {
        get => qfilter.SortAscBy;
        set => qfilter.SortAscBy= value;
      }

      ///<summary>Delegate function to add a 'precursor' filter to <c>IQueryable&lt;T&gt;</c>.</summary>
      public delegate IQueryable<TEntity> PrecursorExpression(IQueryable<TEntity> q, TEntity precursor);
    ///<summary>Delegate function to order <c>IQueryable&lt;T&gt;</c> by precursor.</summary>
    public delegate IQueryable<T> PreorderExpression<T>(IQueryable<T> q);

    ///<summary>Start result after this <see cref="Precursor"/>.</summary>
    public virtual TEntity Precursor { get; set; }

    ///<summary>Expression to filter for results after <see cref="Precursor"/>.</summary>
    public PrecursorExpression PrecursorPredicate { get; set; }
    ///<summary><see cref="Precursor"/> ordering delegte.</summary>
    public PreorderExpression<TEntity> PrecursorOrder { get; set; }

  }

  ///<summary><see cref="QueryFilter{T}"/> extension.</summary>
  public static class FilterOfTExtension {

    ///<summary>Apply this <paramref name="filter"/> on <paramref name="query"/> using <paramref name="filterMap"/> and optional <paramref name="sorterMap"/>.</summary>
    public static IQueryable<T> Apply<T>(this QueryFilter<T> filter,
                                         IQueryable<T> query,
                                         IDictionary<string, QueryFilter.FilterExpression<T>> filterMap,
                                         IDictionary<string, QueryFilter.SorterExpression<T>> sorterMap = null) where T : Entity.Intern.BaseEntity {
      var filteredQuery= query;
      if (null != filter.Properties) foreach (var kv in filter.Properties) {
          if (filterMap.TryGetValue(kv.Key, out var fx))
            filteredQuery= fx(filteredQuery, kv.Value);
        }

      if (null != filter.PrecursorOrder)
        return filteredQuery;

      if (null != sorterMap && null != filter.SortAscBy && 0 != filter.SortAscBy.Count) foreach (var kv in filter.SortAscBy) {
          if (sorterMap.TryGetValue(kv.Key, out var sx))
            filteredQuery= sx(filteredQuery, kv.Value);
        }
      else filteredQuery= filteredQuery.OrderBy(e => e.Id);
      return filteredQuery;
    }

    ///<summary>Apply the limit (start, limit) of this <paramref name="filter"/> on <paramref name="query"/>.</summary>
    public static IQueryable<T> ApplyLimit<T>(this QueryFilter<T> filter, IQueryable<T> query) where T : Entity.Intern.BaseEntity {
      var limit= query;
      if (null != filter.PrecursorPredicate) {
        limit= null != filter.Precursor ? filter.PrecursorPredicate(limit, filter.Precursor) : limit;
        limit= filter.PrecursorOrder(limit);
      }
      else if (filter.Start.HasValue)
        limit= limit.Skip(filter.Start.Value);

      if (filter.Limit.HasValue)
        limit= limit.Take(filter.Limit.Value);
      return limit;
    }

  }
}